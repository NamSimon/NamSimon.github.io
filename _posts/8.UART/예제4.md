![[Pasted image 20240614205337.png]]


```c

#include <avr/io.h>
#include <avr/interrupt.h>
void init();
void txd(char ch);
void txd_string(char *str);
volatile unsigned char Cmd_U0 = 0x30;
volatile unsigned int Count = 0;
unsigned char Fnd[4] = {0};


int main(void){
	unsigned char seg[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
	0x7f, 0x67, 0x77, 0x7c, 0x58,0x5e,0x79, 0x71};
	//unsigned char ch;
	init();
	// terra term에 출력되게 해주는 코드 
	txd_string("\n\r Example 10-4\r");
	txd_string("\n u : up count\r");
	txd_string("\n d : down count\r");
	txd_string("\n s : stop count\r");
	txd_string("\n s : reset count\r\n");
	while(1) {
		//Count 계산해서 Fnd 배열에 저장 
		Fnd[0] = seg[Count/1000];
		Fnd[1] = seg[(Count/100)%10];
		Fnd[2] = seg[(Count/10)%10] | 0x80;
		Fnd[3] = seg[Count%10];
	}
}

ISR(USART0_RX_vect) // keyboard input 시 interrupt 발생
{
	Cmd_U0 = UDR0; /* Cmd_U0 : global 변수 */
}


ISR(TIMER3_COMPA_vect)
{
	/*
		UART0 키보드 입력에 따라 제어하는 코드 
		u일 경우 숫자 증가 10000이 넘으면 자동으로 초기화
		d일 경우 숫자 감소 하지만 Count가 0이 아닐때만 감소 
		s일 경우 현재 Count로 유지 
		r일 경우 Count가 0으로 됨 
	*/
	if( Cmd_U0 == 'u' ){
		Count++;
		if(Count == 10000) Count = 0;
	}
	if(Cmd_U0 == 'd'){
		if(Count!=0)
		{
			Count--;
		}else{
			Count = 0;
		}
	}
	if(Cmd_U0 == 's'){
		Count=Count;
	}
	if (Cmd_U0 == 'r')
	{
		Count=0;
	}
}

ISR(TIMER0_OVF_vect){ // FND 로 출력해주는코드 
	static int count = 0;

	PORTC = Fnd[count];
	PORTG = 8 >> count;
	count++;
	count %= 4;
}

void init()
{
	DDRA = 0xFF;
	DDRB = 0x10;
	DDRC = 0xFF;
	DDRG = 0x0F;
	DDRE = 0x02;
	//EICRB = 0x0A; //EIMSK = 0x30;
	TCCR0 = 0x06; 
	TCNT0 = 0x83;
	TCCR3A = 0x00; 
	TCCR3B = 0x0B; 
	TCCR3C = 0x00; 
	OCR3A = 0x1869;
	TIMSK = 0x01; 
	ETIMSK =0x10;
	UCSR0A = 0x00; 
	UCSR0B = 0x98; 
	UCSR0C = 0x06;
	UBRR0H = 0; 
	UBRR0L = 0x67;
	sei();
}


void txd_string(char *str) // terra term으로 배열 전송해주는 코드 
{
	int i=0;
	while(1) {
		if (str[i] == '\0') break;
		txd(str[i++]);
	}
}

void txd(char ch)
{
	while(!(UCSR0A & 0x20)); // UDRE0=1 ?(전송데이터 empty?)
	UDR0 = ch;
	} /* 1 byte data를 전송 */

```